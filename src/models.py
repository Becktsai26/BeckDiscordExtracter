"""Core data models for the Discord Message Listener application.

Defines DiscordMessage, TradeSignal, ExchangeConfig, TradingConfig, and AppConfig dataclasses.
"""

import json
from dataclasses import dataclass, field
from typing import Optional


@dataclass
class DiscordMessage:
    """Represents a message captured from Discord.

    Used for structured data transfer between the JavaScript MutationObserver
    (via console.log) and the Python application.
    """

    author: str
    content: str
    timestamp: str
    channel: str

    def to_json(self) -> str:
        """Serialize this DiscordMessage to a JSON string.

        The output includes a "type": "DISCORD_MESSAGE" field to distinguish
        this data from other console log output.

        Returns:
            A JSON string representation of this message.
        """
        data = {
            "type": "DISCORD_MESSAGE",
            "author": self.author,
            "content": self.content,
            "timestamp": self.timestamp,
            "channel": self.channel,
        }
        return json.dumps(data, ensure_ascii=False)

    @staticmethod
    def from_json(json_str: str) -> Optional["DiscordMessage"]:
        """Deserialize a JSON string into a DiscordMessage.

        Validates that the JSON contains the required "type" field set to
        "DISCORD_MESSAGE" and all required fields (author, content, timestamp, channel).

        Args:
            json_str: A JSON string to parse.

        Returns:
            A DiscordMessage instance if the JSON is valid, or None if the input
            is invalid (malformed JSON, missing fields, wrong type, etc.).
        """
        try:
            data = json.loads(json_str)
        except (json.JSONDecodeError, TypeError):
            return None

        if not isinstance(data, dict):
            return None

        # Validate the "type" field
        if data.get("type") != "DISCORD_MESSAGE":
            return None

        # Validate all required fields are present and are strings
        required_fields = ("author", "content", "timestamp", "channel")
        for field_name in required_fields:
            if field_name not in data:
                return None
            if not isinstance(data[field_name], str):
                return None

        return DiscordMessage(
            author=data["author"],
            content=data["content"],
            timestamp=data["timestamp"],
            channel=data["channel"],
        )


@dataclass
class TradeSignal:
    """Represents a trading signal generated by the AI Trading Agent.

    Contains the trading pair, direction, confidence level, and analysis summary.
    """

    symbol: str       # e.g. "BTC/USDT"
    side: str         # "BUY" or "SELL"
    confidence: int   # 0-100
    summary: str      # Analysis summary

    def validate(self) -> list[str]:
        """Validate the TradeSignal fields.

        Checks:
        - side must be "BUY" or "SELL"
        - confidence must be an integer between 0 and 100 (inclusive)
        - symbol must be a non-empty string
        - summary must be a non-empty string

        Returns:
            A list of validation error messages. An empty list means validation passed.
        """
        errors: list[str] = []

        # Validate symbol
        if not isinstance(self.symbol, str) or not self.symbol.strip():
            errors.append("symbol must be a non-empty string")

        # Validate side
        if self.side not in ("BUY", "SELL"):
            errors.append("side must be 'BUY' or 'SELL'")

        # Validate confidence
        if not isinstance(self.confidence, int) or isinstance(self.confidence, bool):
            errors.append("confidence must be an integer between 0 and 100")
        elif self.confidence < 0 or self.confidence > 100:
            errors.append("confidence must be an integer between 0 and 100")

        # Validate summary
        if not isinstance(self.summary, str) or not self.summary.strip():
            errors.append("summary must be a non-empty string")

        return errors


@dataclass
class ExchangeConfig:
    """Configuration for a single cryptocurrency exchange."""

    name: str                    # "binance", "bybit", "mexc"
    api_key: str = ""
    api_secret: str = ""
    enabled: bool = False


@dataclass
class TradingConfig:
    """Trading-related configuration parameters."""

    confidence_threshold: int = 70       # 0-100
    max_trade_amount_usdt: float = 100.0
    enabled_exchanges: list[str] = field(default_factory=list)


@dataclass
class AppConfig:
    """Top-level application configuration."""

    cdp_url: str = "http://localhost:9222"
    target_channels: list[str] = field(default_factory=list)
    exchanges: list[ExchangeConfig] = field(default_factory=list)
    trading: TradingConfig = field(default_factory=TradingConfig)
    read_only_mode: bool = True
    llm_model: str = "gpt-4o-mini"
    llm_api_key: str = ""
